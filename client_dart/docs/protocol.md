# 六家统 客户端-服务端 JSON 协议规范

本文档定义使用 JSON 序列化的客户端与服务端通信协议，供 Dart/Flutter 客户端与 Python 服务端联调使用。协议格式与现有 pickle 版本语义一致，仅序列化方式不同。

---

## 一、传输层格式

每条消息由 **4 字节长度头** + **消息体** 组成：

| 部分 | 长度 | 说明 |
|------|------|------|
| Header | 4 字节 | 消息体字节长度，**小端序** 有符号 32 位整数（与 Python `struct.pack('i', len)` 一致） |
| Body   | N 字节 | UTF-8 编码的 JSON 字符串 |

- 收发双方按「先读 4 字节得长度 N，再读 N 字节」的方式拆包。
- 每条消息单独序列化，消息之间无分隔符，顺序严格按下方流程定义。

---

## 二、Card 的 JSON 表示

单张扑克牌：

```json
{
  "suit": "Spade" | "Heart" | "Club" | "Diamond" | "",
  "value": 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| suit | string | 花色：`"Spade"` 黑桃、`"Heart"` 红心、`"Club"` 梅花、`"Diamond"` 方块、`""` 空（大小王） |
| value | int | 牌面：3~10 数字、11 J、12 Q、13 K、14 A、15 2、16 小王、17 大王 |

---

## 三、消息流程与数据类型

### 3.1 登录 / 用户信息（连接建立后）

**客户端 → 服务端**

| 顺序 | 类型 | 说明 |
|------|------|------|
| 1 | `bool` | 是否携带 cookie：`true` 表示有 cookie，`false` 表示无 |
| 2 | `string` | 仅当顺序 1 为 `true` 时发送：cookie 字符串 |

**服务端 → 客户端**

| 顺序 | 类型 | 说明 |
|------|------|------|
| 1 | `bool` | cookie 是否合法：`true` 合法，`false` 不合法 |

若 **cookie 合法**：

| 顺序 | 类型 | 说明 |
|------|------|------|
| 2 | `bool` | 是否恢复成功：`true` 成功，`false` 失败（如仍有客户端在线） |

若 **cookie 不合法**：

- 客户端需再发一条消息：`string` 用户名  
- 服务端再回一条：`string | null`，新 cookie（旁观者为 `null`）

---

### 3.2 等待大厅

服务端周期性发送，直到 6 人满员。客户端循环接收直到 `users_name` 长度为 6。

**服务端 → 客户端**

| 顺序 | 类型 | 说明 |
|------|------|------|
| 1 | `string[]` | 当前大厅用户名单（0~6 个，按座位顺序） |
| 2 | `bool[]` | 对应用户的错误标志，长度与 `users_name` 一致 |

---

### 3.3 场上信息（开局时）

**服务端 → 客户端**

| 顺序 | 类型 | 说明 |
|------|------|------|
| 1 | `bool` | 当前连接是否为玩家：`true` 玩家，`false` 旁观者 |
| 2 | `string[]` | 6 个座位的用户名字 |
| 3 | `int` | 当前连接对应的座位号 `client_player`（0~5） |

---

### 3.4 牌局信息（每轮）

服务端每轮发送一次，客户端收到后更新本地状态；若 `game_over != 0` 则本局结束。

**服务端 → 客户端**

| 顺序 | 类型 | 说明 |
|------|------|------|
| 1 | `int` | `game_over`：0 未结束，非 0 已结束 |
| 2 | `int[]` | 6 个座位的分数 `users_score` |
| 3 | `int[]` | 6 个座位的当前手牌数 `users_cards_num` |
| 4 | `Card[][]` | 6 个座位的本回合出牌 `users_played_cards` |
| 5 | `Card[][]` | **仅当 `game_over != 0` 时发送**：6 个座位的全部手牌 `users_cards` |
| 6 | `Card[]` | 当前连接的手牌 `client_cards` |
| 7 | `int` | 场上当前分数 `now_score` |
| 8 | `int` | 当前出牌人座位号 `now_player`（0~5） |
| 9 | `int` | 头科座位号 `head_master`，-1 表示暂无 |

---

### 3.5 出牌回复（仅玩家且轮到自己时）

客户端需先发送**出牌心跳**，再发送**出牌内容**。

**出牌心跳（轮到自己出牌期间周期性发送）**

**客户端 → 服务端**

| 类型 | 说明 |
|------|------|
| `bool` | 是否已完成出牌：`false` 仍在思考，`true` 已选好牌并即将发送出牌内容 |

**出牌内容**

**客户端 → 服务端**

| 顺序 | 类型 | 说明 |
|------|------|------|
| 1 | `Card[]` | 出牌后的完整手牌 `client_cards` |
| 2 | `Card[]` 或 `["F"]` | 本回合出的牌：正常为 `Card[]`，**跳过**为 `["F"]` |
| 3 | `int` | 出牌后的场上分数 `now_score` |

> **跳过**：当本回合选择不出牌时，第二条消息为 JSON 数组 `["F"]`，即单元素字符串 `"F"`。

---

## 四、流程概览

```
客户端                              服务端
   |                                   |
   |-------- 登录(cookie/用户名) ------->|
   |<------- cookie 合法性/恢复结果 -----|
   |                                   |
   |<======= 等待大厅(users_name等) =====|  循环直到 6 人
   |                                   |
   |<------- 场上信息 -----------------|
   |                                   |
   |<======= 牌局信息(每轮) ============|  循环
   |  若轮到自己:                       |
   |     |-- 出牌心跳(finished=false) ->|
   |     |  ...                         |
   |     |-- 出牌心跳(finished=true) -->|
   |     |-- 出牌内容(牌+分数) -------->|
   |  若 game_over != 0: 退出           |
```

---

## 五、JSON 序列化约定

- 所有消息按上述顺序单独编码为 JSON，每条消息一个 JSON 值。
- `null` 用于表示「无 cookie」等空值。
- 数组、对象与基本类型的 JSON 表示遵循标准。
- 客户端与服务端均使用 UTF-8 编码。

---

## 六、示例

### Card 示例

```json
{"suit": "Spade", "value": 14}
{"suit": "", "value": 16}
```

### 跳过出牌

```json
["F"]
```

### 等待大厅单次响应

```json
["Alice", "Bob", "Carol"]
[false, false, false]
```

---

*协议版本：1.0 | 与 migration_plan.md 附录九、my_network_json.py 一致*
